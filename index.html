<!DOCTYPE html>
<html>
<head>
    <title>슈팅 게임</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
        #gameCanvas {
            border: 1px solid black;
        }
        body {
        overflow: hidden;
        height: 100%;
        background-image: url("/background2.png");
        background-repeat: no-repeat;
        background-size: cover;
        }
        #canvas-container {
        width: 100%;
        text-align:center;
        }
        canvas {
        display: inline;
        }
    </style>
</head>
<body>
    <div id="fpsDisplay"></div>
    <canvas id="gameCanvas"></canvas>
    <script src="main.js"></script>
    <script src="player.js"></script>
    <script src="missile.js"></script>
    <script src="enemy.js"></script>

<script>

    // function setBackground(){
    //     var image = new Image();
    //     image.onload = function() {
    //         context.drawImage(image, 0, 0, canvas.width, canvas.height);
    //     }
    //     image.src = "http://127.0.0.1:3000/background.jpeg";
    // }

    let playerImage,  enemyImage, gameOverImage;
    const loadImage = () => {
        playerImage = new Image();
        playerImage.src = "player2.png"
    }

    loadImage();

    let CONFIG = {
        BASE_SPEED : 4,
        ENEMY_SPEED : 1,
        MISSAILE_SPEED : 8,
        LAST_FRAME_TIME : 0,
        FRAME_INTERVAL : 1000 / 60,
        enemies : [],
        missiles : [],
    }


    // 캔버스 요소 가져오기
    var canvas = document.getElementById("gameCanvas");
    // 그래픽 컨텍스트 가져오기
    let ctx = canvas.getContext("2d");
    const player = new Player();
    const enemy = new Enemy(); //적
    player.startAutoShoot();
    initCanvasSize();


     // 터치 이벤트 처리
    canvas.addEventListener("touchstart", (event) => {
        player.isTouching = true;
        player.touchX = event.touches[0].clientX;
    });
    canvas.addEventListener("touchmove", (event) => {
        if (player.isTouching) {
            var newTouchX = event.touches[0].clientX;
            var deltaX = newTouchX - player.touchX;
            player.x += deltaX;
            player.touchX = newTouchX;
        }
    });

    

    const missileMoveDrowAndMove = () => {
        if (CONFIG.missiles.length > 0) {
            for (const missile of CONFIG.missiles) {
                missile.move();
                missile.draw();

                // 미사일이 화면을 벗어나면 제거
                if (missile.y < 0) {
                    const index = CONFIG.missiles.indexOf(missile);
                    if (index > -1) {
                        CONFIG.missiles.splice(index, 1);
                        
                    }
                    console.log('missiles',CONFIG.missiles)
                }
            }
        }
    } 

    const clamp = (value, min, max) => {
        return Math.min(Math.max(value, min), max);
    };
    const updatePlayerPosition = () => {
        player.x = clamp(player.x, 0, canvas.width - player.width);
        player.y = clamp(player.y, 0, canvas.height - player.height);
    };


    const gameLoop = (timestamp) => { //################# Game Loop ######################
        // 경과 시간 계산
        var deltaTime = timestamp - CONFIG.LAST_FRAME_TIME;
        // 프레임 제어
        if (deltaTime < CONFIG.FRAME_INTERVAL) {
            // 경과 시간이 프레임 간격보다 작으면 다음 프레임으로 넘어가지 않음
            // ctx.clearRect(0, 0, canvas.width, canvas.height);
            requestAnimationFrame(gameLoop);
            return;
        }

        // 화면 지우기
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        //플레이어 그리기
        player.drow();
        enemy.draw();
        // 적 생성
        enemy.spawnEnemy(timestamp);
        // 적 이동
        enemy.moveDown();

        missileMoveDrowAndMove()
        player.handleCollision();
        updatePlayerPosition();

        CONFIG.LAST_FRAME_TIME = timestamp;
        requestAnimationFrame(gameLoop);

        
    }

    // 게임 루프 시작
    requestAnimationFrame(gameLoop);
window.addEventListener('resize', initCanvasSize);
</script>
</body>
</html>
